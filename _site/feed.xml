<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Groot Robot Blog</title>
    <description>Node 개발과 ROS/ROS2를 프로젝트에 적용중인 Developer</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 06 Sep 2020 18:03:07 +0900</pubDate>
    <lastBuildDate>Sun, 06 Sep 2020 18:03:07 +0900</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title></title>
        <description>&lt;h3 id=&quot;chapter-03--프로세스와-스레드&quot;&gt;Chapter 03 : 프로세스와 스레드&lt;/h3&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;01-프로세스의-개념&quot;&gt;01. 프로세스의 개념&lt;/h4&gt;

&lt;p&gt;초기 컴퓨터는 1개의 컴퓨터에 하나의 프로그램이 동작하는 형태의 구조를 가지고있었다. 실행중인 프로그램이 컴퓨터의 모든 자원을 독점하는 이 구조는 불합리하였고, 이를 개선한 다중 프로그래밍 환경에 운영이 가능한 폰 노이만의 &lt;strong&gt;하버드 아키텍처(Harvard architecture)&lt;/strong&gt; 를 채용함으로서 메모리에 여러 프로그램을 적재하는 방식의 컴퓨터 운영방식이 도래하였다.&lt;/p&gt;

&lt;p&gt;이에 따라 병행 되는 프로그램들은 컴퓨터의 CPU의 사용권한을 점유하는데 있어 상호 약속이 필요하게 되었다. 컴퓨터가 메모리에서 ALU / CU 와 같은 심층부에 접근 할때, 메모리 자원의 &lt;strong&gt;동시 점유&lt;/strong&gt; 는 컴퓨터의 크리티컬한 동작을 유발시 킬 수 있기 때문에 이를 시기적절한 타이밍과 메모리 적재 여부를 조절하기 위해 &lt;strong&gt;‘프로세스(Process)’&lt;/strong&gt; 라는 개념이 도입되었다.&lt;/p&gt;

&lt;p&gt;프로세스는 하기와 같이 정의 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실행중인 프로그램&lt;/li&gt;
  &lt;li&gt;비동기적 행위&lt;/li&gt;
  &lt;li&gt;실행 중인 프로시저&lt;/li&gt;
  &lt;li&gt;실행 중인 프로시저의 추적&lt;/li&gt;
  &lt;li&gt;운영체제에 들어있는 프로세스 제어 블록&lt;/li&gt;
  &lt;li&gt;프로세서에 할당하여 실행 할 수 있는 개체가 가능한 대상&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그중에서 가장 이해하기 쉬운 용어는 &lt;strong&gt;‘실행중인 프로그램’&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt;흔히 프로그램이라 함은 ‘정적’인 상태를 의미한다. 컴파일한 코드와 초기화 전역변수, 문자열과 문자열 상수 등 정적 데이터를 포함한 포괄적인 용어로 실제 운영되는 프로그램은 우리가 &lt;strong&gt;‘프로세스’&lt;/strong&gt; 라고 부르는 것이 옳다.&lt;/p&gt;

&lt;p&gt;아무쪼록 이 프로세스라는 개념을 도입한 것은 바로, &lt;strong&gt;메모리&lt;/strong&gt; 라는 녀석 때문이다. 자료구조라는 학문에서는 얼마나 빠른 시간에 메모리에 적재된 데이터를 CRUD 하는 가에 초점이 맞춰져있다고 한다면, 운영체제 학문에서는 &lt;strong&gt;메모리를 기준으로 프로세스가 어떻게 적절하게 치고 빠지는 가?&lt;/strong&gt; 하는 방법에 대해서 서술 하고있다. 이를 위해서는 일단 메모리가 어떤 구조로 이뤄 져있고 어떻게 활용되고 있는지를 확인 할 필요가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/memory.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리는 크게 스택(Stack),힙(Heap),데이터(Data),코드(Code)로 구성되어있다.&lt;br /&gt;
각 개념은 아래 와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;영역&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터를 일시적으로 저장하는 영역, 힙과 인접한 방향으로 데이터를 올려감&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Heap&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;동적으로 메모리를 할당하고 해제할 수있음, 할당된 메모리영역은 위쪽으로 커져감&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로그램의 가상 주소공간, 주로 전역변수나 정적변수를 저장하거나 할당하고 실행하기전에 초기화 함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실행 영역을 포함하는 메모리이거나 목적파일에 있는 프로그램 영역&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;프로세스는 수행하는 역할에 따라 시스템(커널) 프로세스와 사용자 프로세스로 구분하고, 병행 수행 방법에 따라 독립 프로세스와 협력 프로세스로 구분해서 동작한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;종류&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;역할&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;시스템(커널) 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;모든 시스템 메모리와 프로세서의 명령에 엑세스 할 수 있는 프로세스. 프로세스 실행 순서를 제어하거나 다른 사용자 및 커널 영역을 침범하지 못하게 감시하고, 사용자 프로세스를 생성하는 기능을 함.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;역할&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자 코드를 수행하는 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병행 수행 방법&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;독립 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다른 프로세스에 영향을 주지 않거나 다른 프로세스의 영향을 받지 않으면서 수행하는 병행 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병행 수행 방법&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;협력 프로세스&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다른 프로세스에 영향을 주거나 다른 프로세스에서 영향을 받는 병행프로세스&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Sun, 06 Sep 2020 18:03:07 +0900</pubDate>
        <link>http://localhost:4000/2020-08-17-linux-vr-oculus-rift-dk2/</link>
        <guid isPermaLink="true">http://localhost:4000/2020-08-17-linux-vr-oculus-rift-dk2/</guid>
        
        
      </item>
    
      <item>
        <title>Gazebo의 구조와 이해</title>
        <description>&lt;h1 id=&quot;gazebo-의-구조와-이해&quot;&gt;Gazebo 의 구조와 이해&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;Gazebo는 물리시뮬레이션 오픈 소스 프로젝트로서, 대부분 로봇공학자의 필수적인 도구로 활용되고있다. 로봇을 설계하고, 회귀분석과 로봇의 현실적인 시나리오 동작을 가상시뮬레이션을 통해 검증 및 분석하여 사전설계 요소를 검증하거나, 혹은 데이터를 활용한 최근 이슈인 &lt;strong&gt;인공지능,빅데이터&lt;/strong&gt; 와 같은 요소와 접목해 복잡한 실내 및 실외환경에 적합한 물리엔진, 고품격 그래픽과 프로그래밍 인터페이스를 제공한다.&lt;/p&gt;

&lt;p&gt;현재 Gazebo는 Release 버전으로 &lt;strong&gt;Gazebo 11&lt;/strong&gt; 까지 제공하고있으며 이러한 거대하고 가치있는 시뮬레이션은 다양한 패키지와 라이브러리를 활용해 누구나 사용 가능하도록 열려있다.&lt;/p&gt;

&lt;p&gt;이 Post 에서는 Gazebo의 활용방법을 다루지 않는다. 복잡하고 불편한 글로 필자의 지식을 높이고자 개인적으로 정리한 글들을 쓰고 Gazebo 커뮤니티 내에서도 &lt;strong&gt;‘고급’&lt;/strong&gt; 항목에 들어가는 내용을 다룰 것이다. 그렇지만, 누구나 보고 공부하고 이해할 수있는 글로 Gazebo의 내부 구조를 분석하고 공부하고자 한다.&lt;/p&gt;

&lt;h4 id=&quot;gazebo의-기능&quot;&gt;Gazebo의 기능&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;Gazebo는 하기와 같은 기능을 사용자에게 제공하고있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;물리 역학 시뮬레이션&lt;/li&gt;
  &lt;li&gt;고급 3D 그래픽&lt;/li&gt;
  &lt;li&gt;센서 및 노이즈&lt;/li&gt;
  &lt;li&gt;각종 별도의 Plugin API&lt;/li&gt;
  &lt;li&gt;Robot Model&lt;/li&gt;
  &lt;li&gt;TCP/IP를 활용한 시뮬레이션 솔루션&lt;/li&gt;
  &lt;li&gt;클라우드 기반의 시뮬레이션 솔루션&lt;/li&gt;
  &lt;li&gt;각종 Shell Command 기반 검사 및 제어&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 쓰면, 이해하기 힘들지만 간단히 사진 몇장으로 이를 설명드리자면, 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/amazon.gif?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/amazon2.gif?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상기와 같은 솔루션은 Gazebo의 Node.js 기반의 gzserver 와 gzclient 기반으로 이루어진 Web 기반의 시뮬레이션 솔루션에 기반을 둔다고 볼 수 있다. 모두 &lt;strong&gt;비동기&lt;/strong&gt; 형태로 제공되는 서버의 특성을 활용 했다고 볼 수 있으며, 엄청나게 최적화를 하는데 공을 들였다고 볼  수 있다.&lt;/p&gt;

&lt;p&gt;여튼 두서가 길었다. Gazebo는 이러한 것이고 기능은 직접 활용해 보는것으로 충분히 확인이 가능하므로, 우리는 이 구조에 대해 이해하고자 한다.&lt;/p&gt;

&lt;h4 id=&quot;gazebo의-구조&quot;&gt;Gazebo의 구조&lt;/h4&gt;
&lt;hr /&gt;

&lt;p&gt;Gazebo의 물리엔진은 크게 4개의 엔진으로 구성되어 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;영역&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ODE&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Open Dynamic Engine으로 공간에서 물체간 동적 상호작용을 시뮬레이션하는데 활용되는 엔진이다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bullet&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;충돌감지, 강체/연체 물리 시뮬레이션을 위한 2D 전문 물리 엔진이다.  영화의 특수효과 애니메이션 등에도 활용되고있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Simbody&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프로그램의 가상 주소공간, 주로 전역변수나 정적변수를 저장하거나 할당하고 실행하기전에 초기화 함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DART&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실행 영역을 포함하는 메모리이거나 목적파일에 있는 프로그램 영역&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Sat, 29 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/gazebo/</link>
        <guid isPermaLink="true">http://localhost:4000/gazebo/</guid>
        
        
      </item>
    
      <item>
        <title>ROS2로 ROS1과 통신하는 방법(브릿지)</title>
        <description>&lt;h3 id=&quot;ros1-bridge&quot;&gt;ROS1 Bridge&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;오늘은 ROS1 과 ROS2의 브릿지를 어떻게 연결하는지에대 해 알아보겠다.&lt;br /&gt;
ROS2는 아직 -ing(현재진행) 형이다. 아직까지 버그는 많고 보완해야될 부분 이 많다. 그리고 그동안 만들어 뒀던 수많은 ROS1에서 만들어진 pkg는 메타운영체제의 플랫폼이 바뀌었다 하여도, 많은 부분에 있어서 다시 제작해서 사용하는것은 있을수 없는 일이다. 애시당초 ROS의 추구 방향은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재사용성 극대화&lt;/code&gt; 아니던가?&lt;br /&gt;
그래서 ROS1에서 사용되는 많은 Node Pkg는 우리가 기존에 사용하던데로 사용 할 수있도록 ROS1과 ROS2 간에 통신에 ROS1-Bridge가 나오게 된 배경이다.&lt;/p&gt;

&lt;p&gt;이 ROS1 Bridge는 ROS1 과 ROS2 의 노드를 둘다 담당하는 이중 간첩? 같은 역할을 한다.&lt;/p&gt;

&lt;h3 id=&quot;ros1-bridge는-어떻게-사용하나&quot;&gt;ROS1 Bridge는 어떻게 사용하나?&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;ROS1과 ROS2간의 메세지 정의는 package.xml안에 정의된 yaml 파일을 통해 이루어진다.&lt;/p&gt;

&lt;p&gt;이 말이 무엇이냐 하면 yaml 파일을 만들어서 그 안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROS1 관절(Joint1) 메세지 : ROS1 관절(Joint1) 메세지&lt;/code&gt; 라고 적어 두는것이다. &lt;strong&gt;얘 는 얘 에요!&lt;/strong&gt; 라고!&lt;/p&gt;

&lt;p&gt;그래서 ROS2에서 ROS1에서 사용되는 메세지를 받고 싶을 때 yaml 파일 안에 3가지 방식으로 설정해 ROS1에서 오는 메세지 들을 받을 수있도록 돕고 있다.&lt;/p&gt;

&lt;p&gt;더 자세한 원리는 아래 링크를 통해 이해 하는것을 추천 드린다.&lt;br /&gt;
필자도 해당 링크를 통한 내용을 기반으로 설명 드리는 것임을 미리 말씀 드린다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ros2/ros1_bridge/blob/master/doc/index.rst&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ROS1 Bridge를 사용하기 이전에 이 구성 환경을 어떻게 맞춰 주어야 하는지 이해 할 필요가 있다.&lt;/p&gt;

&lt;p&gt;가장 먼저 해야 할 일은 bashrc에서 브릿지에 대한 기본 설정을 해주어 ROS1과 ROS2 시스템의 명령어가 둘다 통용되는 환경을 Ubuntu 내에 구성 해 줄 필요가 있다. 
어짜피 기본적으로 ROS 나 ROS2를 깔아 보신분들의 경우 알겠지만, 일단 해당 명령어 들은 그냥 보통 &lt;strong&gt;~/.bashrc&lt;/strong&gt; 에 추가해 두었을 것이다. 미리 source로&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ROS Melodic의 setup.bash 설정
source /opt/ros/melodic/setup.bash  
source /opt/ros/dashing/local_setup.bash  
source /home/user/catkin_ws/devel/setup.bash  

# ROS2 Foxy의 setup.bash 설정
source /home/user/ros2_ws/install/local_setup.bash  


# ROS1
export ROS_DISTRO=melodic   
source /opt/ros/$ROS_DISTRO/setup.bash  
source /home/user/catkin_ws/devel/setup.bash  

# ROS2
export ROS_DISTRO=dashing
source /opt/ros/$ROS_DISTRO/setup.bash
source /home/user/ros2_ws/install/local_setup.bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 30 Jul 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ros2-ros1/</link>
        <guid isPermaLink="true">http://localhost:4000/ros2-ros1/</guid>
        
        
      </item>
    
      <item>
        <title>ROS1과 ROS2의 차이</title>
        <description>&lt;h2 id=&quot;목-차&quot;&gt;목 차&lt;/h2&gt;
&lt;p&gt;※ ROS1 과 ROS2 에 대한 차이를 알고 싶으신 분은 1번만 참고하시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#1-ros-1-과-ros-2-의-차이점-비교&quot;&gt;1. ROS1 과 ROS2의 차이점 비교&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#h4-id1-application-layer-1181-application-layerh4&quot;&gt;Application Layer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#h4-id2-middleware-layer-842-middleware-layerh4&quot;&gt;Middleware Layer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#h4-id3-지원-os-3593-지원-osh4&quot;&gt;지원 OS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#h4-id4-지원언어-2504-지원언어h4&quot;&gt;지원 언어&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#h4-id다중-node-지원-여부-및-roslaunch의-메커니즘-107다중-node-지원-여부-및-roslaunch의-메커니즘h4&quot;&gt;기타&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;#2-ros-1-과-ros-2-는-통신이-가능한가&quot;&gt;2. ROS 1 과 ROS 2 는 통신이 가능한가?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3-ros-2-는-ros-1-의-한계를-극복하기위해-만들어-진다&quot;&gt;3. ROS 2 는 ROS 1 의 한계를 극복하기위해 만들어 진다&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#4-ros-2-와-그-이전의-개념-탑재하기&quot;&gt;4. ROS 2 와 그 이전의 개념 탑재하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-ros-1-과-ros-2-의-차이점-비교&quot;&gt;1. ROS 1 과 ROS 2 의 차이점 비교&lt;/h2&gt;

&lt;h3 id=&quot;아키텍쳐-비교&quot;&gt;아키텍쳐 비교&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/ros_diffrence.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;비교&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ROS 1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ROS 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application layer&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;항상 ROS Master가 필요  [ roscore 실행]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DDS 기반 미들웨어안에서만 동작  [roscore 안해]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Middleware Layer&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자 정의 위주의 중앙 메커니즘&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;추상 미들웨어 인터페이스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지원 OS&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리눅스만 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리눅스/윈도우/맥/ 기타 RTOS 등..&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지원 언어&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Python2 &amp;amp; C++ 11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Python3 &amp;amp; C++ 14,17&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다중 Node(프로그램)의 지원 여부&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;한 프로세스에 한 노드만 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;한 프로세스에 다중 노드 지원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;roslaunch의 동작 메커니즘&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Xml 기반의 제한된 구조의 실행(은근 빡침)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;복잡한 실행을 Python으로 간편하게&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;1-application-layer&quot;&gt;1. Application Layer&lt;/h4&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;회고---ros-1-의-통신-방식&quot;&gt;회고 - ROS 1 의 통신 방식&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/6.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;기존의 ROS1에서는 'roscore' 라는 별도의 마스터를 두고 통신을 진행하였다. 
이 마스터는 중개자로서 각종 노드에서 발생하는 Publisher 와 Subscriber 사이에서 일어나는 통신을 중재하였는데 이런 통신에서 XMLRPC(Xml Remote Procedure Call)을 사용하여 상호작용 하였다.
'roscore' 명령어를 실행 할 경우 roscore.xml 을 포함하는 launch file을 실행하는데, 해당 xml 안에 내 ROS_MASTER_URI 주소를 사용해 rosmaster가 받아 들일 IP주소 및 PORT를 사용해 마스터를 관리 및 사용한다.
여기서 마스터와 슬레이브는 토픽,서비스,액션립의 방식을 활용해 서로 통신을 진행하였었다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;통신 이름&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;동기/비동기&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;방향&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;특징&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;부연&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Topic&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비동기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;단방향&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;연속 데이터 수신 용&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1:1 , 1:N , N:N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;동기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;양방향&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청 처리가 일시적인 현재 상태에 대한 요청 및 응답&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Request / Response&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Action&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비동기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;양방향&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청 처리 후 피드백이 오래 걸리거나 중간 피드백이 필요한 경우&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Goal / FeedBack / Result&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;ros-2의-통신방식&quot;&gt;ROS 2의 통신방식&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;ROS2의 경우 DDS(Data Distribution Service)라는 통신방식을 활용하여 기존의 통신방식을 개선하였다.&lt;br /&gt;
도데체 DDS가 뭔데 ROS2에서 이를 도입하였을까? 이 DDS 통신에 대해서만 제대로 이해 해도 일단 ROS1 과 ROS2의 차이는 절반을 이해했다고 해도 된다. 
우선 이 통신 표준을 설립한 OMG(Object Management Group)에 대해서 알아보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/7.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;omg-object-management-group&quot;&gt;OMG (Object Management Group)&lt;/h4&gt;
&lt;p&gt;OMG는 1989년 4월 HP, SUN 등 11개 업체에 의해 발족된 OMG는 이러한 표준화를 선두에서 이끌고 있는 조직으로 현재 전 세계 800여 개 이상의 회사가 소속된 컨소시엄 형태의 비영리단체이다.&lt;/p&gt;

&lt;p&gt;주로 정보기술 환경에 관련 된 표준화를 수립하는 일을 하고있으며, MOF,UML,XMI 등의 객체 관리 표준 모델을 제시하고 전파하고있다.&lt;/p&gt;

&lt;p&gt;그리고 이 기관에서 꽤?(8년이나 지났지만) 최근에 제시한 객체 모델이 바로 DDS이다.&lt;/p&gt;

&lt;h4 id=&quot;그래서-ddsdata-distribution-service-가-뭔데&quot;&gt;그래서 DDS(Data Distribution Service) 가 뭔데?&lt;/h4&gt;
&lt;p&gt;DDS는 기존 클라이언트 - 서버 기반의 노드간 상호 동작을 중심이 아니라 노드 상호간 공유/교환 되어야 할 데이터 자체에 중심을 둔 데이터 배포 메커니즘이라고 &lt;strong&gt;ETRI&lt;/strong&gt; 에 기술되어 있다. 간단히 말하자면 원래 통신을 할 때는 서버랑 클라이언트 끼리 해야 되는게 맞지만, 워낙 시대가 좋아져서 기기들마다 통신이 되다보니 모두 연결하기엔 HW가 후달린다. 또, 즉각 대응이라는(실시간) 부담 역시 안고가야하는 통신이 요구되면서, 이런 통신 풀을 가운데(미들웨어)에서 관리하고(스케쥴링) 신뢰도를 높여(Qos) 통신 할 순 없을 까 하고 나온게 DDS란 말씀. 이로 인해 Domain ID만 가지고 통신이 되기에 Socket 이 필요없이 통신을 할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;또한, 이러한 통신방식은 OS와 HW에 자유로우며,언어에 독립적이기 때문에 플랫폼에 자유롭다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/10.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러다 보니 자연스럽게 DDS 통신이 놓이는 포지션은 하기와 같이 쓰이게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/8.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;즉, DDS는 다양한 통신 객체들의 대량 데이터를 관리하는 통신 미들웨어&lt;/strong&gt; 라고 볼 수 있다.
DDS 개념은 네트워크프로그래밍 영역이라 ROS 자체에서 뭔가 깊게 설명하기 그렇다. 사실 ROS는 종합 예술적 오픈소스 프로젝트로 어느 한분야를 깊게 들어가면 끝도 없다. 수많은 전문가들이 만든 이 아름다운 도구를 우리는 이렇게 손쉽게 사용하고 있는것이다.&lt;/p&gt;

&lt;p&gt;DDS와 경쟁을 하는 통신으로는 비동기통신의 CORBA, JMS 의 P2P 통신방식이 있다. 이건 검색을 통해 독자들이 직접 찾아 이해 했으면 하는 마음이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.itfind.or.kr/WZIN/jugidong/1456/file3719-145601.pdf&quot;&gt;공부-링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;자, 이제 DDS가 뭔지는 알겠다. OMG라는 기관에서 만들었고 미들웨어라는 사실, 그리고 이것은 프로토콜이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;표준&lt;/code&gt; 이라는 사실.&lt;/p&gt;

&lt;p&gt;그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;왜 이걸 쓰는데?&lt;/code&gt; 라고 물어 볼 수 있을것이다.&lt;/p&gt;

&lt;p&gt;앞에서 살짝 언급했었지만 이를 좀더 구체적으로 설명 하기 위해 다시 앞서 이야기 했던 내용을 언급하고자 한다.&lt;/p&gt;

&lt;h4 id=&quot;왜-dds를-쓰는건데&quot;&gt;왜 DDS를 쓰는건데?&lt;/h4&gt;

&lt;p&gt;우리는 바야흐로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4차 산업혁명&lt;/code&gt;의 시대에 살고있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4차 산업혁명&lt;/code&gt;이 무엇인가? 모든 디바이스의 커넥션과 통신속도의 진화, 대용량 데이터의 부상, 인공지능 알고리즘의 혁신, 이를 받쳐주는 HW의 격변을 이야기 할 수 있을것이다. 이런 복잡한 통신디바이스가 대량으로 연결되고 관리되기 위해서는 통신 시스템의 고도화가 진행되기 마련이고 시스템 구조 역시 엄청나게 복잡해 진다. HW 개량 뿐 아니라 소프트웨어 개발 공수도 몇배로 늘어나게 된다. 이러면 시스템 아키텍쳐를 설계하는 설계자 입장에서 모든것을 간단히, 간편하게 설계하고 싶은 열망을 누구나 가지게 될것이다. 왜? 내가 편하려고! 그래서 나오게 된것이 바로 &lt;strong&gt;구독과 발간의 통신 모델&lt;/strong&gt; 이라고 볼수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://m.blog.naver.com/PostView.nhn?blogId=neos_rtos&amp;amp;logNo=220346180839&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&quot;&gt;공부-링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DDS로 넘어오는것은 ROS1에서 시작햇던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연구자 및 개발자&lt;/code&gt;를 목적으로 개발했던 초기와는 달리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;필드에서 직접 운용 가능한 ROS&lt;/code&gt;를 지향하는 방향으로 간것이라 볼 수있다.&lt;/p&gt;

&lt;p&gt;필자는 생산기술 필드에서 설비제작을 진행 하면서 1%의 불량도 용납하지 않는 생산필드를 충족 시킬 설비를 제작해야됬는데, 이러한 요구를 위해서는 멈춤,지연 이란 있을 수 없고 철저히 빠르게 동작을 수행 하는 설비만이 유효한 라인에 투입될 수있음을 몸소 체험했다.&lt;/p&gt;

&lt;p&gt;웃자고 하는 말이지만 열약하기 짝이없는 중소기업에서 모터제어 같은건 고려대상에 포함도 안되있고 그냥 공압시스템 설계로 모션동작은 퉁치는 경우가 허다하다. 싼맛에 최적화 해서 쓰는 필드이다 보니, 조금이라도 주변환경이 변하거나 문제가 생기면 참 답없이 관리되거나 버려지는일도 허다하다.&lt;/p&gt;

&lt;p&gt;여하튼 ROS2의 요구에 화답이라도 하듯 DDS는 &lt;strong&gt;국방,빌딩,산업용&lt;/strong&gt; 통신 방식에 쓰일 목적으로 개발되었다. 애초에 QoS(Quality of Service) 통신, Secure Realtime 통신 등만 보아도 통신의 품질 및 안정성에 주안을 두고 Node간 통신을 수행 하도록 만들었구나를 알 수 있다.&lt;/p&gt;

&lt;p&gt;PS : 참고로 ROS2 의 최고 돈줄이 미국국방성(DoD),NSA 다.&lt;/p&gt;

&lt;h3 id=&quot;제대로-뜯어보자-ros2-통신&quot;&gt;제대로 뜯어보자 ROS2 통신&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/9.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;상기 그림은 ROS2에서의 DDS 통신의 아키텍쳐 이다. 
여기서 쓰이는 rmw,rcl 등 용어에 대해 설명하고 이해하고자 한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자 저 광활한 아키텍쳐를 보라 일단, 초입자 입장에서 볼때 모르는 용어들 부터 하나씩 정리해보자&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 파랑색 부분의 FastRTPS,RTI Connext 는 무엇인가?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RTPS(Real Time Publish Subscribe) 라는 녀석은 OMG에서 만든 녀석이다. 이녀석을 만든 목적은 디바이스와 디바이스 간에 time-critical/실시간으로 안전하게 정보 공유가 필요한 환경에서 대응하고자 함인데 이를 위해 &lt;strong&gt;데이터 분산서비스 표준의 기반이 되는 프로토콜&lt;/strong&gt; 을 만들고 publish/subscribe 패턴을 이용해서 확장성, 실시간성, 독립성, 고성능, 상호 정보 교환이 가능하도록 만들었다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTI&lt;/code&gt; 역시 회사 이름이며 이회사에서 만든 각종 DDS 솔루션 이름들이 RTI Connext .. 으로열거 되어있다고 보면된다. 우리나라도 &lt;strong&gt;ETRI&lt;/strong&gt; 에서 한국형 DDS를 개발한 내용이 있으니 심심하면 공부하는것도 추천드린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. rmw 는 무엇인가?&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rmw(ROS Middleware Interface)라고 부르며, 앞서 열거드린 '퍼랭이'들의 욕망을 모두 품어주시는 벤더에 자유로우며, 구독 및 발간, 원격함수 호출등의 인터페이스를 제공하고있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3. rcl 은 무엇인가?&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rcl(ROS Client library)는 C 라이브러리로 공간,시간,로깅 등 ROS의 기본기능을 제공한다.
또한 rcl 위에 각종 언어를 지원하도록 인터페이스를 지원하며 rclcpp, rclpy, rcljava 등으로 ROS2 클라이언트 라이브러리로 지원하고있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4. rclcpp, rclpy, rcljava은 무엇인가?&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;다양한 언어로 생성된 node 들을 실행 하기위해 ROS2 에 지원하는 기능으로 각종 언어를 활용해 노드를 실행 할 수있도록 돕는 rcl 들이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 계층별로 통신이 진행되는 시나리오를 말씀드리자면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UDP&lt;/code&gt;로 올라온 물리신호가 각 벤더가 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DDS&lt;/code&gt; 표준을 타고(FastRTPS,RTI Connext..) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmw&lt;/code&gt;에서 표준화 되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rcl&lt;/code&gt;을 통해 각 클라이언들 만의 언어로 해석되어 메세지통신이 &lt;strong&gt;구독 및 발간&lt;/strong&gt; 형태로 이뤄 진다고 이해 할 수 있다.&lt;/p&gt;

&lt;p&gt;자, 위 글들을 통해 우리는 대략적인 ROS2의 통신에 대해 수박 겉핥기를 해보았다.&lt;br /&gt;
좀 더, 상세한 이해를 위해서는 추후 다룰 글에서 ROS2의 rcl통신을 직접 짜보면서 DDS 메커니즘을 이해 할 필요가 있다.&lt;/p&gt;

&lt;p&gt;상기 글을 요약하자면, DDS 통신의 특징은 하기와 같이 기술될 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;발간/구독(Publish/Subscribe) 통신 방식 : 데이터 중심적인 통신이 가능하며, 방대한 양의 데이터 전송과 처리에 적합&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자동 디스커버리(discovery) 기능 : 시스템의 동적인 구성 변화에 자동 대응&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일정 시간 내(deterministic) 데이터 전송 기능 : 실시간 데이터 전송 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다양한 통신 방식 : 일대일(one-to-one), 일대다(one-to-many), 다대일(many-to-one), 다대다(many-to-many) 통신 지원&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다양하고 상세한 메시지 전송 제어용 QoS(Quality of Service) 파라미터 제공 : 시스템 목적에 따른 다양한 데이터 전달 정책을 선택 적용 가능&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-middleware-layer&quot;&gt;2. Middleware Layer&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;미들웨어 부분은 위에서 언급했던 내용의 연장선이다. ROS1에서의 통신방식이 ROS_MASTER의 장부 등록으로 인한 &lt;strong&gt;구독 및 발간&lt;/strong&gt; 형태의 통신 모델이었다고 한다면, ROS2의 DDS 모델을 따라, 미들웨어 중심의 &lt;strong&gt;구독 및 발간&lt;/strong&gt; 모델로 변경되면서 추상적인 통신형태를 가지고 간다고 이해 할 수있다. &lt;a href=&quot;#h4-id1-application-layer-2281-application-layerh4&quot;&gt;Application Layer&lt;/a&gt; 부분을 제대로 읽었다면 굳이 참고하지 않더라도 당연하다 라고 이해하면 될것같다.&lt;/p&gt;

&lt;h4 id=&quot;3-지원-os&quot;&gt;3. 지원 OS&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;DDS 통신의 특징이 무엇인가, 운영체제와 HW로 부터 독립적인 통신 모델을 수립하는것이다. 기존에도 ROS1에서 리눅스 한정이긴 했으나, 안드로이드 및 기타 리눅스 운영체제 위에서는 자유롭게 통신이 가능하였다. ROS2에서는 이보다 더 넓게, Personal한 영역까지 커버리지 할 수준의 범위로 늘었다. Window 및 IOS 등 더이상 운영체제의 틀에 고립되지 않은 완벽하게 자유로운 미들웨어로 운영되기 때문에 ROS2의 동작영역은 운영체제를 더이상 고려하지 않아도 되게 되었다.&lt;/p&gt;

&lt;h4 id=&quot;4-지원언어&quot;&gt;4. 지원언어&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;2020년 1월 1일 부로 Python 2.7이 지원을 종료하면서, 언어의 변화에 맞춰 ROS2 역시 지원 중단된 언어들을 걷어내고 Python3 로 넘어갔다. 사실 시대가 진화하면 언어도 같이 진화하는것은 당연하므로 이는 당연한 수순이라고 여겨진다. 운영체제 역시 거기에 맞춰 지원 언어에 대해 맞춰 같을 것이다. 현재 ROS2 에서는 Python3 및 C++ 14,17 을 지원하도록 설계되어있다. rclpy,rclcpp 운용 시 참고하면 될것이다.&lt;/p&gt;

&lt;h4 id=&quot;다중-node-지원-여부-및-roslaunch의-메커니즘&quot;&gt;다중 Node 지원 여부 및 roslaunch의 메커니즘&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;아래 글을 참조하면 될것같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#4-ros-2-와-그-이전의-개념-탑재하기&quot;&gt;참고&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이로서, ROS1과 ROS2의 기본적인? 차이점에 대해 한번 알아보았다. 좀더 구체적이고 자세한 글은 시간 날때마다 하나씩 정리해서 올리도록 하겠다.  긴 글인 만큼 정확한 이해가 요구되며, 필자 역시 매우 미흡한 ROS 입문자로서 잘못된 정보나 오기가 있을 경우 메일로 알려주시면 감사하겠다.&lt;/p&gt;

&lt;h3 id=&quot;ros-2-의-명령어-특징&quot;&gt;ROS 2 의 명령어 특징&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;ros2 node list
    &lt;ul&gt;
      &lt;li&gt;실행 중인 ROS 2 환경에 node 목록 호출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ros2 node info &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/실행중인 node&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;실행 중인 Node 의 정보 확인
        &lt;h4 id=&quot;node-info&quot;&gt;Node info&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Subscribers : 메세지 발행자 목록 [ 토픽 통신 : 단방향 메세지 통신 ]&lt;/li&gt;
  &lt;li&gt;Publishers : 메세지 구독자 목록  [ 토픽 통신 : 단방향 메세지 통신 ]&lt;/li&gt;
  &lt;li&gt;Service Servers : 서비스 서버 정보 [ 양방향 통신 : req / res ]
    &lt;ul&gt;
      &lt;li&gt;DescribeParameters&lt;/li&gt;
      &lt;li&gt;GetParameterTypes&lt;/li&gt;
      &lt;li&gt;ListParameters&lt;/li&gt;
      &lt;li&gt;SetParametersAtomically&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service Clients : 서비스 클라이언트 [ 양방향 통신 : req / res ]&lt;/li&gt;
  &lt;li&gt;Action Servers : 액션 서버 [ 양방향 통신 : goal / result / feedback ]&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Action Clients : 액션 클라이언트 [ 양방향 통신 : goal / result / feedback ]&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 이와 같이 ROS 1 에서 사용했던 명령어와 동일하나 앞에 ` 2 ` 를 붙여 실행하는 것이 특징
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-ros-1-과-ros-2-는-통신이-가능한가&quot;&gt;2. ROS 1 과 ROS 2 는 통신이 가능한가?&lt;/h2&gt;

&lt;p&gt;ROS1 시절 부터 수많은 패키지 들이 개발되어왔다. 이러한 ROS 1 전용 툴을 ROS 2 에서 재개발 하는것이 아닌 재사용을 하기위하여, ROS 2에서는 Bridge node를 활용해 ROS 1에서 사용 되어온 패키지를 재사용 해 재개발의 번거로움을 극복하였다.&lt;/p&gt;

&lt;p&gt;ROS1 과 ROS2 두 메타운영체제 간의 통신을 위해서는 별도의 세팅이 필요로 되어진다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ros1_bridge node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ros1_bridge node&lt;/code&gt; 는 ROS1 과 ROS2간의 통신을 위해 만들어진 노드이다.&lt;br /&gt;
사용방법은 ROS 1 에서 Publish 되고있는 msg가 있을때, ROS 2 에서 해당 메세지를 받고 싶을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ros2 run ros1_bridge '브릿지 명'&lt;/code&gt; 을 통해 받도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※ 이때, 사용자는 ROS1 과 ROS2가 동일한 ROS_MASTER_URI 를 사용하고 있어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-ros-2-는-ros-1-의-한계를-극복하기위해-만들어-진다&quot;&gt;3. ‘ROS 2’ 는 ‘ROS 1’ 의 한계를 극복하기위해 만들어 진다&lt;/h2&gt;

&lt;p&gt;ROS2가 나오기 전 필자가 두대 이상의 로봇을 한 공간에 시뮬레이션을 굴리려고 하면 여간 골치아픈 작업이 아닐 수가 없었다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gazebo&lt;/code&gt;에 두대 이상의 시뮬레이션을 넣고싶어 ROS 1 으로 환경을 구축할 때, 이용 해야했던 xml,yaml,launch 구조는 일반적인 방법으로  ROS 들이 하기에는 매우 적합하지 못했다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;group&amp;gt;&lt;/code&gt; 태그 안에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tf_prefix&lt;/code&gt; 를 생성해 별도의 link,joint 그룹을 생성하고 동작에 대한 별도의 node 를 형성 해 실행하는데 있어 그리고 두개 이상의 rviz를 moveit 으로 병행해 Python으로 동작시키는것은 상당히 번거롭다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/1.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;두대의 6축 로봇을 `Gazebo` 안에서 두개의 Rviz로 제어하는 모습
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/2.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;두대 이상의 로봇은 보다 복잡한 tf map을 그린다.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/3.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;두대 이상의 로봇의 node는 group 내에서 더 복잡하게 얽혀있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 형태의 번거로운 구조를 ROS2에서는 보다 간편하고 쉽게 풀어나가는 모습을 보여준다.&lt;/p&gt;

&lt;h1 id=&quot;4-ros-2-와-그-이전의-개념-탑재하기&quot;&gt;4. ROS 2 와 그 이전의 개념 탑재하기&lt;/h1&gt;
&lt;p&gt;ROS 1 시절부터 배워왔던 개념을 다시 정립하고자 해당 내용을 보충하고자 한다. &lt;br /&gt;
이 컬럼은 과거에 잠시 기록해 두엇던 내용이므로 추후 따로 분리하여 올릴 예정이다.&lt;/p&gt;

&lt;h4 id=&quot;ros-에서-pkg-란-무엇인가&quot;&gt;ROS 에서 pkg 란 무엇인가?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;ROS에서 패키지란 ?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;cpp 파일, python 파일, configuration 파일, compilation 파일, launch 파일, and parameters 파일을 종합적으로 묶어 놓은 도구를 일컫는다. 패키지에 대한 추상적 개념부터 특징에 대해 말하자면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 모든 ROS 프로그램은 패키지로 구성된다.
2. 당신이 만드는 모든 ROS 프로그램은 패키지로 구성되야 한다.
3. 패키지는 ROS 프로그램의 주요 시스템이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;패키지는 직접 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catkin_create_pkg&lt;/code&gt; 명령어를 통해 직접 만들 수 도 있으며, 또는 직접 패키지를 설치하여 관리 할 수 있다.&lt;/p&gt;

&lt;p&gt;설치된 패키지들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/opt/ros/groovy/share/&lt;/code&gt; 의 경로에서 관리되며 생성된 패키지가 없을 경우 사용이 불가하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;대표적인 pkg 중 하나인 'MoveIt! Setup Assistant'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/4.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ROS에서 패키지를 생성한 경우 다음과 같은 디렉터리 구조를 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/gwkim9444/gwkim9444.github.io/blob/master/_posts/picture/5.png?raw=true&quot; alt=&quot;Relation&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config 폴더 : ROS 패키지에서 사용하는 모든 환경 설정 파일들을 보관
scripts 폴더 :실행 가능한 python script를 보관
action 폴더 : action 정의를 포함해 보관
srv 폴더 : 서비스 정의를 포함해 보관
msg 폴더 : 맞춤형 메세지 정의를 포함해 보관
launch 폴더 : launch files을 보관하는 장소 (하나 이상의 node를 실행하기위해)
src 폴더 : 실행 가능한 Cpp file을 보관하는 장소
CMakeLists.txt : CMake 빌드환경에 대한 기술
package.xml : 패키지 정보가 담긴 xml 구조의 파일
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 디렉토리 이외에도 개발자들 사이에서 control 폴더, config 폴더[configuration],urdf 폴더 등으로 구조를 지니고 있으며, 큰 단위의 로봇 프로젝트를 진행 할 때&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;로봇이름_description : 로봇 모델에 대한 상세 기술&lt;/li&gt;
  &lt;li&gt;로봇이름_controller : 로봇 동작을 위한 상세 기술&lt;/li&gt;
  &lt;li&gt;로봇이름_gazebo : gazebo 내 모델에 대한 기술&lt;/li&gt;
  &lt;li&gt;로봇이름_hw_interface : 로봇 자체의 hw interface를 위한 pkg&lt;/li&gt;
  &lt;li&gt;로봇이름_drvier : 4번과 동일&lt;/li&gt;
  &lt;li&gt;로봇이름_moveit_config : moveit으로 생성한 pkg&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;등의 형태로 로봇 패키지를 관리하는 작명센스를 보이고있다. 이와 관련된 내용은 프로젝트 진행자 마다 다르므로 건너뛰기로 한다. 필자는 독일에 kuka, ur로봇, 국내 indy series, robotis의 manipulator 에 대한 프로젝트 진행자들이 짠 구조에 대한 내용을 참조함을 이해 바란다.&lt;/p&gt;

&lt;p&gt;자, 앞서 이야기 했던 긴 이야기는 ROS 1 이라는 거대한 맥락의 일부이나, 우리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROS2&lt;/code&gt; 를 배우고 있다. 그렇다면 기존에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launch&lt;/code&gt; 를 통해 실행되었던 우리의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pkg&lt;/code&gt;는 지금 어떤 식으로 관리 되고 있을까 ?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#아키텍쳐-비교&quot;&gt;아키텍쳐 비교&lt;/a&gt; 에서 설명했듯 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xml&lt;/code&gt; 형태로 실행 되었던 우리의 분노게이지를 올렸던 ROS1의 pkg 관리 방식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;으로 대체되었다. 그 차이를 아래 글에서 설명하고자 한다.&lt;/p&gt;

&lt;p&gt;ROS1 시절 실행되었던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xml&lt;/code&gt; 형태의 실행 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;launch&amp;gt;
    &amp;lt;arg name=&quot;매개변수 설정&quot; doc=&quot;매개변수에 대한 설명&quot; default=&quot;입력 없을때 설정할 값&quot; /&amp;gt;
    &amp;lt;param name=&quot;파라미터 이름&quot; type=&quot;타입(자료형)&quot; value=&quot;$(arg 매개변수)&quot;/&amp;gt;
    &amp;lt;node name=&quot;실행할 node 이름&quot; type=&quot;실행할 프로그램.py or 실행할 프로그램.cpp&quot; pkg=&quot;패키지 이름&quot; /&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ROS 1에서는 이런 형태로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launch&lt;/code&gt;에 쌈싸먹듯 프로그램을 굴려야 했다면&lt;/p&gt;

&lt;p&gt;ROS2에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;으로 굴린다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LaunchDescription&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;launch_ros.actions&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generate_launch_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LaunchDescription&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;launch_ros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'패키지 이름'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_executable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'실행 할 cpp 이름'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'터미널에 뿌릴지 로그파일로 남길지 등을 선택'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;해당 py 프로그램을 생성한 뒤&lt;/p&gt;

&lt;p&gt;CMake.txt file 내에 아래 내용의 코드를 추가해 준다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}/
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아까 위 글에서 설명하였듯, 모든 pkg는 opt/ros/share 에서 관리되고 있다. 해당 프로젝트를 추가함으로서 CMake build 환경을 구성한다.&lt;/p&gt;

&lt;p&gt;그다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catkin_build --symlink-install&lt;/code&gt; 명령어를 입력해 빌드 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ros2 launch 패키지 이름 패키지 실행파일.py&lt;/code&gt; 하면 정상적으로 ROS1에서 패키지 launch 하는 것과 동일한 실행을 진행 할 수 있다.&lt;/p&gt;

&lt;p&gt;이런식으로 우리는 기존 ROS1 과 다른 형태의 실행방식에 적응해야된다. ROS2 에는 다양한 언어를 지원하기 위한 Ros Client library(RCL) 을 지원한다. 다양한 언어로 생성된 node 들을 실행 하기위해 ROS2 에 유지보수 팀이 직접 RCL을 관리하고 있다.&lt;/p&gt;

&lt;p&gt;아래 라이브러리는 ROS2 팀에서 관리하는 RCL 이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rclcpp = C++ 클라이언트 라이브러리
rclpy = Python 클라이언트 라이브러리
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;출저&quot;&gt;출저&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.naver.com/neos_rtos/30173805276&quot;&gt;한컴MDS-Blog&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.hellot.net/new_hellot/magazine/magazine_read.html?code=201&amp;amp;sub=002&amp;amp;idx=44385&amp;amp;page=239&amp;amp;list=all&quot;&gt;첨단-헬로티&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://discourse.ros.org/t/ros-2-seminar/12872&quot;&gt;표윤석박사님_ROS2_Seminar&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://discourse.ros.org/&quot;&gt;ROS-Discourse&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Jul 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ros1-ros2/</link>
        <guid isPermaLink="true">http://localhost:4000/ros1-ros2/</guid>
        
        
      </item>
    
  </channel>
</rss>